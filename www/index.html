<!doctype html>
<html>
  <head>
    <title>Map</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
      }
      
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        width: 300px;
      }
      
      #search-container {
        margin-bottom: 10px;
      }
      
      #search-input {
        width: 75%;
        padding: 8px;
        border-radius: 3px;
        border: 1px solid #ccc;
      }
      
      #search-button {
        width: 20%;
        padding: 8px;
        border-radius: 3px;
        border: 1px solid #0066cc;
        background: #0066cc;
        color: white;
        cursor: pointer;
      }
      
      #location-info {
        font-size: 14px;
        margin-top: 10px;
      }
      
      #location-select-mode {
        display: none;
        background: rgba(255, 200, 0, 0.8);
        color: black;
        padding: 5px;
        border-radius: 3px;
        font-weight: bold;
        margin-top: 5px;
        text-align: center;
      }
      
      #destinations {
        margin-top: 10px;
        max-height: 150px;
        overflow-y: auto;
      }
      
      .destination-item {
        padding: 5px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }
      
      .destination-item.highlighted {
        background-color: #d0e0f0;
        font-weight: bold;
      }
      
      .destination-item:hover {
        background-color: #f0f0f0;
      }
      
      #debug-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 5px;
        border-radius: 3px;
        z-index: 1000;
        font-size: 12px;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphlib/2.1.8/graphlib.min.js"></script>
  </head>

  <body>
    <div id="controls">
      <div id="search-container">
        <input type="text" id="search-input" placeholder="Search for a destination">
        <button id="search-button">Go</button>
      </div>
      <div id="location-info">
        Current Location: Getting location...
      </div>
      <div id="location-select-mode">
        LOCATION SELECT MODE - Click anywhere on the map
      </div>
      <div id="destinations">
        <h4>Destinations</h4>
        <!-- Destination list will be populated here -->
      </div>
    </div>
    
    <div id="debug-overlay">
      <div>Press D to toggle debug info</div>
      <div id="debug-info" style="display: none;"></div>
    </div>
    
    <img
      id="image"
      src="SchoolMap.png"
      alt="Sample Image"
      style="display: none"
    />
    <canvas id="canvas"></canvas>

    <script>
      var canvas = document.getElementById("canvas");
      var img = document.getElementById("image");
      var locationInfo = document.getElementById("location-info");
      var searchInput = document.getElementById("search-input");
      var searchButton = document.getElementById("search-button");
      var destinationsContainer = document.getElementById("destinations");
      var locationSelectMode = document.getElementById("location-select-mode");
      var highlightedDestinationItem = null;
      
      // Map data
      var map;
      var geoJsonData;
      var userLocation = null;
      var isLocationSelectMode = false;
      // IMPORTANT: These are the original reference destinations
      // They should NOT be modified as they're used for the coordinate system
      var referenceDestinations = [
        { name: "Building A", coordinates: "-122.067600,37.360700" },
        { name: "Building B", coordinates: "-122.067300,37.360400" },
        { name: "Library", coordinates: "-122.067750,37.360300" },
        { name: "Cafeteria", coordinates: "-122.067200,37.360800" },
        { name: "Gymnasium", coordinates: "-122.067500,37.360550" }
      ];
      
      // These are the destinations that can be changed for UI purposes
      var destinations = JSON.parse(JSON.stringify(referenceDestinations));
      
      var debugMode = false;
      var debugInfo = document.getElementById("debug-info");
      
      // Toggle debug mode with D key
      document.addEventListener('keydown', function(event) {
        if (event.key.toLowerCase() === 'd') {
          debugMode = !debugMode;
          debugInfo.style.display = debugMode ? 'block' : 'none';
          if (debugMode) {
            updateDebugInfo();
          }
        }
      });
      
      function updateDebugInfo() {
        if (!debugMode) return;
        
        let html = "<h4>Reference Coordinates</h4><ul>";
        referenceDestinations.forEach(dest => {
          const [lng, lat] = dest.coordinates.split(",");
          const imgCoords = gpsToImageCoordinates(parseFloat(lng), parseFloat(lat));
          html += `<li>${dest.name}: GPS(${lng},${lat}) Image(${imgCoords.x.toFixed(1)},${imgCoords.y.toFixed(1)})</li>`;
        });
        html += "</ul>";
        
        if (userLocation) {
          const [lng, lat] = userLocation.split(",");
          const imgCoords = gpsToImageCoordinates(parseFloat(lng), parseFloat(lat));
          html += `<p>User: GPS(${lng},${lat}) Image(${imgCoords.x.toFixed(1)},${imgCoords.y.toFixed(1)})</p>`;
        }
        
        debugInfo.innerHTML = html;
      }
      
      // Initialize destinations list
      function populateDestinations() {
        destinationsContainer.innerHTML = "<h4>Destinations</h4>";
        destinations.forEach(dest => {
          const item = document.createElement("div");
          item.className = "destination-item";
          item.textContent = dest.name;
          item.setAttribute("data-coordinates", dest.coordinates);
          item.onclick = function() {
            // Remove highlight from previous item
            if (highlightedDestinationItem) {
              highlightedDestinationItem.classList.remove('highlighted');
            }
            // Add highlight to current item
            this.classList.add('highlighted');
            highlightedDestinationItem = this;
            
            navigateTo(this.getAttribute("data-coordinates"), dest.name);
          };
          destinationsContainer.appendChild(item);
        });
      }
      
      // Search functionality
      searchButton.addEventListener("click", function() {
        const searchTerm = searchInput.value.trim().toLowerCase();
        if (searchTerm === "") return;
        
        const filteredDestinations = destinations.filter(dest => 
          dest.name.toLowerCase().includes(searchTerm)
        );
        
        if (filteredDestinations.length > 0) {
          navigateTo(filteredDestinations[0].coordinates, filteredDestinations[0].name);
        } else {
          alert("Destination not found");
        }
      });
      
      // Location override with keybind (press 'L')
      document.addEventListener('keydown', function(event) {
        if (event.key.toLowerCase() === 'l' && event.ctrlKey && event.shiftKey) {
          // Prevent default browser behavior for this key combination
          event.preventDefault();
          
          isLocationSelectMode = !isLocationSelectMode;
          locationSelectMode.style.display = isLocationSelectMode ? 'block' : 'none';
          
          if (isLocationSelectMode) {
            canvas.style.cursor = 'crosshair';
            console.log("Location select mode activated (Ctrl+Shift+L to toggle)");
          } else {
            canvas.style.cursor = 'default';
            console.log("Location select mode deactivated");
          }
        }
      });
      
      // Get user's current location
      function getUserLocation() {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            function(position) {
              // Convert GPS coordinates to our map coordinates
              const latitude = position.coords.latitude;
              const longitude = position.coords.longitude;
              
              // For debugging, show the raw GPS coordinates
              console.log("Raw GPS:", latitude, longitude);
              
              // For this demo, we'll attempt to convert GPS to our map coordinates
              // But since these are likely not in the same reference frame, we still use a fallback
              try {
                userLocation = convertGpsToMapCoordinates(latitude, longitude);
                console.log("Converted coordinates:", userLocation);
                
                // If the converted location is far outside our map bounds, use the fallback
                const mapCoords = userLocation.split(",").map(parseFloat);
                const imgCoords = gpsToImageCoordinates(mapCoords[0], mapCoords[1]);
                
                // Just for debugging - check if these coordinates are within reasonable bounds
                console.log("Image coordinates:", imgCoords.x, imgCoords.y);
                
                // If conversion clearly puts us outside the image, use fallback
                if (isNaN(imgCoords.x) || isNaN(imgCoords.y) || 
                    imgCoords.x < 0 || imgCoords.y < 0 || 
                    imgCoords.x > canvas.width*2 || imgCoords.y > canvas.height*2) {
                  console.log("Converted coordinates outside map bounds, using fallback");
                  userLocation = destinations[0].coordinates;
                }
              } catch (e) {
                console.error("Error converting GPS coordinates:", e);
                userLocation = destinations[0].coordinates;
              }
              
              // Note we display longitude first (X), then latitude (Y)
              locationInfo.textContent = "Current Location: Long: " + longitude.toFixed(6) + ", Lat: " + latitude.toFixed(6);
              
              // Force redraw to show the user location
              drawBaseMap();
            },
            function(error) {
              locationInfo.textContent = "Error getting location: " + error.message;
              console.error("Error getting user location:", error);
              
              // Fallback to a default location
              userLocation = destinations[0].coordinates;
              
              // Force redraw to show the user location
              drawBaseMap();
            }
          );
        } else {
          locationInfo.textContent = "Geolocation is not supported by this browser.";
          
          // Fallback to a default location
          userLocation = destinations[0].coordinates;
          
          // Force redraw to show the user location
          drawBaseMap();
        }
      }
      
      // Add these variables near the top of the script, with the other var declarations
      var locationSelectedTime = 0;
      var isLocationHighlighted = false;
      
      // Draw user location on the map
      function drawUserLocation(ctx) {
        if (!userLocation || !map) return;
        
        // Use our fixed transformation system
        let [lng, lat] = userLocation.split(",").map(parseFloat);
        let imgCoords = gpsToImageCoordinates(lng, lat);
        let x = imgCoords.x;
        let y = imgCoords.y;
        
        if (debugMode) {
          updateDebugInfo();
        }
        
        // Debug marker positions
        console.log("Drawing user location at map coordinates:", lng, lat);
        console.log("Converted to image coords:", x, y);
        
        // Calculate highlight effect for when location is first selected
        const timeSinceSelection = Date.now() - locationSelectedTime;
        const highlightRadius = isLocationHighlighted ? 
          15 + 10 * Math.sin(timeSinceSelection / 100) * Math.exp(-timeSinceSelection / 1000) : 15;
        
        // After 3 seconds, stop the highlight animation
        if (timeSinceSelection > 3000) {
          isLocationHighlighted = false;
        }
        
        // Draw outer highlight that animates when first selected
        ctx.beginPath();
        ctx.arc(x, y, highlightRadius, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
        ctx.fill();
        ctx.closePath();
        
        // Draw outer glow
        ctx.beginPath();
        ctx.arc(x, y, 15, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
        ctx.fill();
        ctx.closePath();
        
        // Draw location point
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
        ctx.fill();
        ctx.strokeStyle = "rgb(0, 0, 0)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();
        
        // Draw "You are here" label with better visibility
        ctx.font = "bold 16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        
        // Draw text outline for better visibility
        ctx.lineWidth = 3;
        ctx.strokeStyle = "black";
        ctx.strokeText("YOU ARE HERE", x, y - 20);
        
        // Draw text fill
        ctx.fillStyle = "white";
        ctx.fillText("YOU ARE HERE", x, y - 20);
        
        // Update display with coordinates
        // Order should be longitude, latitude (X, Y)
        let coordDisplay = `Current Location: Long: ${lng.toFixed(6)}, Lat: ${lat.toFixed(6)}`;
        locationInfo.textContent = coordDisplay;
        
        // If in highlighted mode, request animation frame to continue animation
        if (isLocationHighlighted) {
          requestAnimationFrame(drawBaseMap);
        }
      }
      
      // Navigate to a destination
      function navigateTo(destinationCoords, destinationName) {
        if (!userLocation || !map) {
          alert("Current location not available yet");
          return;
        }
        
        // Highlight the destination in the list
        if (highlightedDestinationItem) {
          highlightedDestinationItem.classList.remove('highlighted');
        }
        const items = destinationsContainer.getElementsByClassName('destination-item');
        for (let item of items) {
          if (item.getAttribute('data-coordinates') === destinationCoords) {
            item.classList.add('highlighted');
            highlightedDestinationItem = item;
            break;
          }
        }
        
        // Redraw the map to clear previous paths
        drawBaseMap();
        
        // Draw the path
        drawShortestPath(map, userLocation, destinationCoords);
        
        // Update location info
        locationInfo.textContent = `Route: Current Location → ${destinationName}`;
      }
      
      // Draw the base map
      function drawBaseMap() {
        var ctx = canvas.getContext("2d");

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Save the default state
        ctx.save();
        
        // Set a fixed scale for better visibility
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
        
        // Center the image
        const translateX = (canvas.width - img.width * scale) / 2;
        const translateY = (canvas.height - img.height * scale) / 2;
        
        // Apply transformations in the correct order
        ctx.translate(translateX, translateY);
        ctx.scale(scale, scale);
        
        // Draw the base image
        ctx.drawImage(img, 0, 0);

        // Apply additional transformations for coordinate system
        ctx.translate(img.width * 0.027, img.height * 1.225);
        ctx.rotate(-Math.PI / 2);
        ctx.scale(1, -1);
        
        // Draw paths if GeoJSON data is available
        if (geoJsonData) {
          console.log("Drawing paths from GeoJSON data");
          drawGeoJson(ctx, geoJsonData);
        } else {
          console.log("No GeoJSON data available yet");
        }
        
        // Draw user location - let's make sure this is visible by logging state
        if (userLocation && map) {
          console.log("Drawing user location:", userLocation);
          console.log("- Canvas size:", canvas.width, canvas.height);
          console.log("- Scale factor:", scale);
          console.log("- Translation:", translateX, translateY);
          
          // Draw a visible marker at the user's location
          drawUserLocation(ctx);
        } else {
          console.log("User location not available yet");
        }
        
        // Restore the context to its default state
        ctx.restore();
        
        // Request frame update for smooth animations
        requestAnimationFrame(function() {
          // Only continue animation if in location mode or navigating
          if (isLocationSelectMode) {
            drawBaseMap();
          }
        });
      }

      img.onload = function () {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        console.log("Image dimensions - Width: " + img.width + ", Height: " + img.height);
        console.log("Canvas dimensions - Width: " + canvas.width + ", Height: " + canvas.height);

        // Initialize the application
        getUserLocation();
        populateDestinations();
        drawBaseMap();
      };

      var x_scale = 293672.2068325253;
      var y_scale = 397822.00000022055;
      var x_offset = 35848504.38460734;
      var y_offset = -14863206.834465902;

      // Fixed reference points for mapping (based on current destinations, but won't change if destinations change)
      var fixedReferencePoints = [
        { name: "Reference 1", gps: { lng: -122.067600, lat: 37.360700 }, 
          image: { x: -122.067600 * x_scale + x_offset, y: 37.360700 * y_scale + y_offset } },
        { name: "Reference 2", gps: { lng: -122.067300, lat: 37.360400 }, 
          image: { x: -122.067300 * x_scale + x_offset, y: 37.360400 * y_scale + y_offset } },
        { name: "Reference 3", gps: { lng: -122.067750, lat: 37.360300 }, 
          image: { x: -122.067750 * x_scale + x_offset, y: 37.360300 * y_scale + y_offset } }
      ];
      
      // Convert from GPS coordinates to image coordinates
      function gpsToImageCoordinates(longitude, latitude) {
        // Using the fixed reference system based on the original reference destinations
        // This ensures transformation is independent of the current destinations
        const x = longitude * x_scale + x_offset;
        const y = latitude * y_scale + y_offset;
        return { x, y };
      }
      
      // Convert from image coordinates back to GPS coordinates
      // This is the inverse of the transformation in interpolation.py
      function imageToGpsCoordinates(x, y) {
        // Inverse of the scale transformation - not dependent on destinations
        const longitude = (x - x_offset) / x_scale;
        const latitude = (y - y_offset) / y_scale;
        return { longitude, latitude };
      }
      
      // Convert from screen coordinates to image coordinates
      function screenToImageCoordinates(screenX, screenY) {
        // Canvas transformations - not dependent on destinations
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
        const translateX = (canvas.width - img.width * scale) / 2;
        const translateY = (canvas.height - img.height * scale) / 2;
        
        // First, undo the canvas translation and scaling
        screenY = -(screenY-canvas.height/2) + canvas.height/2;
        const canvasX = (screenX - translateX) / scale;
        const canvasY = (screenY - translateY) / scale;

        console.log("Canvas coords after undoing translation/scale:", canvasX, canvasY);
        
        // These transformations are now fixed and don't depend on destinations
        // Original transformations were:
        // 1. ctx.translate(img.width * 0.027, img.height * 1.225);
        // 2. ctx.rotate(-Math.PI / 2);
        // 3. ctx.scale(1, -1);
        
        // For rotation: instead of -Math.PI/2 (clockwise), try Math.PI/2 (counter-clockwise)
        // For a counter-clockwise 90-degree rotation:
        // x' = -y
        // y' = x
        
        // These values are now fixed regardless of destinations
        const unrotatedX = canvasY;
        const unrotatedY = -canvasX;
        
        // These fixed offsets are no longer tied to destinations
        const finalX = unrotatedX + img.width * 0.145;
        const finalY = unrotatedY + img.height * 0.038;
        
        console.log("Final image coords:", finalX, finalY);
        
        return { x: finalX, y: finalY };
      }
      
      // Convert GPS coordinates to map coordinates
      function convertGpsToMapCoordinates(latitude, longitude) {
        // This function just returns the raw GPS coordinates now
        // It doesn't depend on destinations - just a direct passthrough
        return `${longitude},${latitude}`;
      }

      function drawGeoJson(ctx, geoJsonData) {
        if (!geoJsonData) return;

        geoJsonData.features.forEach((feature) => {
          if (feature.geometry.type === "LineString") {
            ctx.beginPath();

            // Set style properties once
            ctx.strokeStyle = "rgb(0, 0, 255)";
            ctx.lineCap = "round";
            ctx.lineWidth = 5;

            // Move to the first coordinate
            var firstCoord = feature.geometry.coordinates[0];
            var x = firstCoord[0] * x_scale + x_offset;
            var y = firstCoord[1] * y_scale + y_offset;
            ctx.moveTo(x, y);

            // Draw lines to subsequent coordinates
            feature.geometry.coordinates.slice(1).forEach((coord) => {
              var x = coord[0] * x_scale + x_offset;
              var y = coord[1] * y_scale + y_offset;
              ctx.lineTo(x, y);
            });

            // Stroke the path
            ctx.stroke();
            ctx.closePath();
          }
        });
      }

      function updateGraphFromGeoJson(geoJsonData, graph) {
        let map = new graphlib.Graph({ directed: false });

        geoJsonData.features.forEach((feature) => {
          if (feature.geometry.type === "LineString") {
            let coordinates = feature.geometry.coordinates;

            for (let i = 0; i < coordinates.length - 1; i++) {
              let [x1, y1] = coordinates[i];
              let [x2, y2] = coordinates[i + 1];

              // Convert to a string key for graph nodes
              let node1 = `${x1},${y1}`;
              let node2 = `${x2},${y2}`;

              // Add nodes if they don't exist
              if (!map.hasNode(node1)) map.setNode(node1);
              if (!map.hasNode(node2)) map.setNode(node2);

              // Calculate Euclidean distance as edge weight
              let dx = x2 - x1;
              let dy = y2 - y1;
              let distance = Math.sqrt(dx * dx + dy * dy);

              // Add edge if it doesn't exist
              if (!map.hasEdge(node1, node2)) {
                map.setEdge(node1, node2, distance);
              }
            }
          }
        });

        return map;
      }

      function drawShortestPath(map, startNode, endNode) {
        var ctx = canvas.getContext("2d");
        
        // Save context to restore later
        ctx.save();
        
        // Apply the same transformations as in drawBaseMap
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
        const translateX = (canvas.width - img.width * scale) / 2;
        const translateY = (canvas.height - img.height * scale) / 2;
        
        ctx.translate(translateX, translateY);
        ctx.scale(scale, scale);
        ctx.translate(img.width * 0.027, img.height * 1.225);
        ctx.rotate(-Math.PI / 2);
        ctx.scale(1, -1);

        let dijkstraResult = graphlib.alg.dijkstra(map, startNode, (e) =>
          map.nodeEdges(e),
        );
        console.log(dijkstraResult);

        // Extract the shortest path
        let path = [];
        let currentNode = endNode;

        path.unshift(startNode);

        for (let node of map.nodes()) {
          if (dijkstraResult[node].distance != "Infinity") {
            console.log([node, dijkstraResult[node].predecessor]);
          }
        }

        console.log("Shortest Path:", path);

        // Draw the shortest path
        ctx.beginPath();
        ctx.strokeStyle = "rgb(255, 0, 0)"; // Red color for the shortest path
        ctx.lineCap = "round";
        ctx.lineWidth = 5;

        // Move to the first node
        let firstNode = path[0].split(",");
        let x = parseFloat(firstNode[0]) * x_scale + x_offset;
        let y = parseFloat(firstNode[1]) * y_scale + y_offset;
        ctx.moveTo(x, y);

        // Draw lines to subsequent nodes
        path.slice(1).forEach((node) => {
          let [x, y] = node.split(",").map(parseFloat);
          x = x * x_scale + x_offset;
          y = y * y_scale + y_offset;
          ctx.lineTo(x, y);
        });

        // Stroke the path
        ctx.stroke();
        ctx.closePath();
        
        // Restore the context
        ctx.restore();
      }

      // When the data loads, draw the paths and initialize the app
      fetch("graph.json", {
        method: 'GET',
        mode: 'cors', // Enable CORS
        headers: {
          'Content-Type': 'application/json'
        }
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error('Network response was not ok: ' + response.statusText);
          }
          return response.json();
        })
        .then((data) => {
          console.log("GeoJSON data loaded successfully");
          geoJsonData = data;
          map = updateGraphFromGeoJson(geoJsonData, graphlib);
          console.log("Graph created with", map.nodeCount(), "nodes");
          
          // Force redraw with the loaded data
          drawBaseMap();
        })
        .catch(error => {
          console.error('Error fetching graph data:', error);
        });

      // Add the canvas to the DOM
      document.body.appendChild(canvas);

      // When the window is resized, redraw the map
      window.addEventListener('resize', function() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawBaseMap();
      });

      // Handle map clicks for location override
      canvas.addEventListener('click', function(event) {
        if (!isLocationSelectMode) return;
        
        // Get click position relative to canvas
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        
        console.log("Click at screen coords:", clickX, clickY);
        
        // Convert screen coordinates to image coordinates
        const imageCoords = screenToImageCoordinates(clickX, clickY);
        console.log("Converted to image coordinates:", imageCoords.x, imageCoords.y);
        
        // Convert image coordinates to GPS coordinates
        const gpsCoords = imageToGpsCoordinates(imageCoords.x, imageCoords.y);
        console.log("Converted to GPS coordinates:", gpsCoords.longitude, gpsCoords.latitude);
        
        // Set the new user location
        userLocation = `${gpsCoords.longitude},${gpsCoords.latitude}`;
        locationInfo.textContent = `Current Location: Long: ${gpsCoords.longitude.toFixed(6)}, Lat: ${gpsCoords.latitude.toFixed(6)}`;
        
        // Check if we're near a known destination for better labeling
        let closestDest = null;
        let minDist = 0.0005; // Threshold distance in GPS coordinates
        
        for (const dest of destinations) {
          const [destLng, destLat] = dest.coordinates.split(",").map(parseFloat);
          const dx = gpsCoords.longitude - destLng;
          const dy = gpsCoords.latitude - destLat;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist < minDist) {
            minDist = dist;
            closestDest = dest;
          }
        }
        
        if (closestDest) {
          console.log("Near known destination:", closestDest.name, "distance:", minDist.toFixed(6));
          locationInfo.textContent = `Current Location: ${closestDest.name}`;
          // We'll keep the exact coordinates for better precision
        }
        
        // Exit location select mode
        isLocationSelectMode = false;
        locationSelectMode.style.display = 'none';
        canvas.style.cursor = 'default';
        
        // Redraw the map with animation effect for selection
        locationSelectedTime = Date.now();
        isLocationHighlighted = true;
        drawBaseMap();
        
        // Display confirmation message
        const confirmationMsg = document.createElement('div');
        confirmationMsg.textContent = 'Location selected!';
        confirmationMsg.style.position = 'absolute';
        confirmationMsg.style.left = clickX + 'px';
        confirmationMsg.style.top = (clickY - 30) + 'px';
        confirmationMsg.style.backgroundColor = 'rgba(0, 200, 0, 0.8)';
        confirmationMsg.style.color = 'white';
        confirmationMsg.style.padding = '5px 10px';
        confirmationMsg.style.borderRadius = '5px';
        confirmationMsg.style.pointerEvents = 'none';
        confirmationMsg.style.zIndex = '1000';
        confirmationMsg.style.opacity = '1';
        confirmationMsg.style.transition = 'opacity 2s';
        
        document.body.appendChild(confirmationMsg);
        
        // Fade out and remove after 2 seconds
        setTimeout(function() {
          confirmationMsg.style.opacity = '0';
          setTimeout(function() {
            if (document.body.contains(confirmationMsg)) {
              document.body.removeChild(confirmationMsg);
            }
          }, 2000);
        }, 500);
      });
    </script>
  </body>
</html>
