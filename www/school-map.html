<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>School Map Navigation</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    #map-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 300px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 1000;
    }

    #search-container {
      display: flex;
      margin-bottom: 10px;
    }

    #search-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px 0 0 4px;
      font-size: 14px;
    }

    #search-button {
      padding: 8px 12px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 0 4px 4px 0;
      cursor: pointer;
    }

    #location-info {
      margin-top: 10px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.4;
    }

    #coordinates-display {
      margin-top: 5px;
      font-family: monospace;
      font-size: 13px;
      color: #0066cc;
      font-weight: bold;
    }
    
    #copy-coords-btn {
      margin-top: 8px;
      padding: 6px 12px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }
    
    #copy-coords-btn:hover {
      background: #45a049;
    }
    
    #copy-status {
      display: none;
      margin-top: 5px;
      color: #45a049;
      font-size: 12px;
      text-align: center;
    }

    #location-select-mode {
      display: none;
      margin-top: 10px;
      padding: 8px;
      background: rgba(255, 200, 0, 0.8);
      color: black;
      font-weight: bold;
      text-align: center;
      border-radius: 4px;
    }
    
    #manual-location-btn {
      margin-top: 8px;
      padding: 6px 12px;
      background: #ff9800;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #manual-location-btn:hover {
      background: #e68a00;
    }
    
    #keybinds {
      margin-top: 15px;
      padding: 8px;
      background: #e9e9e9;
      border-radius: 4px;
      font-size: 12px;
    }
    
    #keybinds h4 {
      margin: 0 0 5px 0;
      font-size: 13px;
    }
    
    .keybind {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
    }
    
    .key {
      background: #ddd;
      padding: 1px 5px;
      border-radius: 3px;
      font-family: monospace;
      font-weight: bold;
    }

    #places-list {
      margin-top: 15px;
      max-height: 300px;
      overflow-y: auto;
    }

    .place-item {
      padding: 8px;
      margin-bottom: 5px;
      background: #eee;
      border-radius: 4px;
      cursor: pointer;
    }

    .place-item:hover {
      background: #ddd;
    }

    .place-item.selected {
      background: #d0e0f0;
      font-weight: bold;
    }

    #debug-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 1000;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 20px;
      border-radius: 5px;
      font-size: 18px;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <div id="loading">Loading map data...</div>
  
  <div id="map-container">
    <canvas id="canvas"></canvas>
    
    <div id="controls">
      <h2>School Map Navigation</h2>
      <div id="search-container">
        <input type="text" id="search-input" placeholder="Search for a location">
        <button id="search-button">Go</button>
      </div>
      <div id="location-info">Your location: Waiting for GPS...</div>
      <div id="coordinates-display"></div>
      <button id="copy-coords-btn" style="display: none;">Copy Coordinates</button>
      <button id="manual-location-btn">Set Location Manually</button>
      <div id="copy-status">Coordinates copied!</div>
      <div id="location-select-mode">
        LOCATION SELECT MODE - Click anywhere on the map
      </div>
      <div id="places-list"></div>
      
      <div id="keybinds">
        <h4>Keyboard Shortcuts</h4>
        <div class="keybind">
          <span><span class="key">L</span> Set location manually</span>
        </div>
        <div class="keybind">
          <span><span class="key">D</span> Toggle debug info</span>
        </div>
      </div>
    </div>
    
    <div id="debug-overlay">
      <div>Press D to toggle debug info</div>
      <div id="debug-info" style="display: none;"></div>
    </div>
  </div>

  <script>
    // Main variables
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const searchInput = document.getElementById('search-input');
    const searchButton = document.getElementById('search-button');
    const locationInfo = document.getElementById('location-info');
    const coordinatesDisplay = document.getElementById('coordinates-display');
    const copyButton = document.getElementById('copy-coords-btn');
    const copyStatus = document.getElementById('copy-status');
    const manualLocationButton = document.getElementById('manual-location-btn');
    const placesList = document.getElementById('places-list');
    const locationSelectMode = document.getElementById('location-select-mode');
    const debugInfo = document.getElementById('debug-info');
    const loadingIndicator = document.getElementById('loading');
    
    // State variables
    let mapImage = new Image();
    let graphData = [];
    let places = [];
    let userLocation = null;
    let selectedPlace = null;
    let isLocationSelectMode = false;
    let debugMode = false;
    let pathToDestination = null;
    
    // Scale and offset values from interpolation.py
    const x_scale = 293672.2068325253;
    const y_scale = 397822.00000022055;
    const x_offset = 35848504.38460734;
    const y_offset = -14863206.834465902;
    
    // Track mouse position for crosshair
    let lastMouseX = null;
    let lastMouseY = null;
    
    // Initialize the application
    async function init() {
      try {
        // Load the map image
        await loadImage('SchoolMap.png');
        
        // Resize canvas to fit the window
        resizeCanvas();
        
        // Load graph data from CSV
        await loadGraphData('data.csv');
        
        // Try fetching data.csv directly
        if (graphData.length === 0) {
          console.log("First attempt to load CSV failed, trying alternative method...");
          await loadGraphDataDirectly();
        }
        
        // Initialize places data
        initializePlaces();
        
        // Draw the map
        drawMap();
        
        // Get user location
        getUserLocation();
        
        // Hide loading indicator
        loadingIndicator.style.display = 'none';
      } catch (error) {
        console.error('Error initializing application:', error);
        loadingIndicator.textContent = 'Error loading map data. Please refresh the page.';
      }
    }
    
    // Load the map image
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        mapImage.onload = () => resolve();
        mapImage.onerror = () => reject(new Error('Failed to load image'));
        mapImage.src = src;
      });
    }
    
    // Resize canvas to fit the window
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    // Load graph data from CSV
    async function loadGraphData(csvFile) {
      try {
        const response = await fetch(csvFile);
        if (!response.ok) {
          throw new Error(`Failed to load ${csvFile}: ${response.status} ${response.statusText}`);
        }
        const csvText = await response.text();
        
        // Parse CSV
        const lines = csvText.split('\n');
        const headers = lines[0].split(',').map(h => h.trim());
        
        console.log(`CSV file loaded: ${lines.length} lines including header`);
        
        // Skip header row and parse data
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line) {
            // Handle CSV formatting issues - remove spaces after commas
            const values = line.split(',').map(v => parseFloat(v.trim()));
            if (!isNaN(values[0])) {
              // Invert the y-coordinates (y1 and y2)
              graphData.push({
                x1: values[0],
                y1: -values[1], // Invert y1
                x2: values[2],
                y2: -values[3], // Invert y2
                weight: values.length > 4 ? values[4] : 1
              });
            }
          }
        }
        
        console.log(`Loaded ${graphData.length} graph edges from CSV with inverted y-coordinates`);
        
        // Add debug info about the first few edges
        if (graphData.length > 0) {
          console.log("Sample edges with inverted y-coordinates:");
          for (let i = 0; i < Math.min(5, graphData.length); i++) {
            console.log(`Edge ${i}:`, graphData[i]);
          }
        } else {
          console.warn("No valid graph edges found in CSV file");
        }
      } catch (error) {
        console.error('Error loading CSV data:', error);
        loadingIndicator.textContent = `Error: ${error.message}`;
        throw error;
      }
    }
    
    // Alternative method to load graph data directly
    async function loadGraphDataDirectly() {
      // Hard-coded sample data as a fallback
      // This ensures the application works even if CSV loading fails
      graphData = [
        { x1: 100, y1: -200, x2: 300, y2: -400, weight: 1 },
        { x1: 300, y1: -400, x2: 500, y2: -300, weight: 1 },
        { x1: 500, y1: -300, x2: 700, y2: -500, weight: 1 },
        { x1: 700, y1: -500, x2: 900, y2: -400, weight: 1 },
        { x1: 900, y1: -400, x2: 1100, y2: -600, weight: 1 },
        { x1: 100, y1: -600, x2: 300, y2: -500, weight: 1 },
        { x1: 300, y1: -500, x2: 500, y2: -700, weight: 1 },
        { x1: 500, y1: -700, x2: 700, y2: -600, weight: 1 },
        { x1: 700, y1: -600, x2: 900, y2: -700, weight: 1 }
      ];
      
      console.log(`Loaded ${graphData.length} fallback graph edges with inverted y-coordinates`);
      
      return true;
    }
    
    // Initialize places data
    function initializePlaces() {
      // Extract unique points from graph data to use as places
      const uniquePoints = new Map();
      
      graphData.forEach(edge => {
        // Create a unique ID for each point
        const id1 = `${edge.x1},${edge.y1}`;
        const id2 = `${edge.x2},${edge.y2}`;
        
        if (!uniquePoints.has(id1)) {
          uniquePoints.set(id1, {
            id: id1,
            name: `Location ${uniquePoints.size + 1}`,
            x: edge.x1,
            y: edge.y1,
            imageX: edge.x1,
            imageY: edge.y1
          });
        }
        
        if (!uniquePoints.has(id2)) {
          uniquePoints.set(id2, {
            id: id2,
            name: `Location ${uniquePoints.size + 1}`,
            x: edge.x2,
            y: edge.y2,
            imageX: edge.x2, 
            imageY: edge.y2
          });
        }
      });
      
      // Convert map to array
      places = Array.from(uniquePoints.values());
      
      // Add some named locations (with inverted y-coordinates)
      const namedLocations = [
        { id: 'entrance', name: 'Main Entrance', x: 538.086, y: 332.921 },
        { id: 'cafeteria', name: 'Cafeteria', x: 1761, y: 698.598 },
        { id: 'library', name: 'Library', x: 1236.65, y: 504.378 },
        { id: 'gym', name: 'Gymnasium', x: 643.965, y: 335.5 },
        { id: 'admin', name: 'Administration', x: 950, y: 400 }
      ];
      
      // Find and update existing places or add new ones
      namedLocations.forEach(loc => {
        // Find the closest point in our existing places
        let closestPlace = null;
        let minDistance = Infinity;
        
        places.forEach(place => {
          const distance = Math.sqrt(
            Math.pow(place.x - loc.x, 2) + 
            Math.pow(place.y - loc.y, 2)
          );
          
          if (distance < minDistance) {
            minDistance = distance;
            closestPlace = place;
          }
        });
        
        // If we found a close match, update its name
        if (closestPlace && minDistance < 50) {
          closestPlace.name = loc.name;
          closestPlace.id = loc.id;
        } else {
          // Otherwise add as a new place
          places.push({
            id: loc.id,
            name: loc.name,
            x: loc.x,
            y: loc.y,
            imageX: loc.x,
            imageY: loc.y
          });
        }
      });
      
      // Calculate GPS coordinates for each place
      places.forEach(place => {
        const gps = imageToGpsCoordinates(place.imageX, place.imageY);
        place.longitude = gps.longitude;
        place.latitude = gps.latitude;
      });
      
      // Populate places list in UI
      updatePlacesList();
    }
    
    // Update the places list in the UI
    function updatePlacesList() {
      placesList.innerHTML = '<h3>Places</h3>';
      
      places.forEach(place => {
        if (place.name.startsWith('Location')) {
          return; // Skip unnamed locations
        }
        
        const item = document.createElement('div');
        item.className = 'place-item';
        if (selectedPlace && selectedPlace.id === place.id) {
          item.classList.add('selected');
        }
        
        item.textContent = place.name;
        item.dataset.id = place.id;
        
        item.addEventListener('click', () => {
          selectPlace(place);
        });
        
        placesList.appendChild(item);
      });
    }
    
    // Select a place
    function selectPlace(place) {
      selectedPlace = place;
      updatePlacesList();
      
      // If we have user location, find path
      if (userLocation) {
        findPath(userLocation, place);
      }
      
      // Update UI
      locationInfo.textContent = `Selected: ${place.name}`;
      
      // Redraw the map
      drawMap();
    }
    
    // Find path between two points
    function findPath(start, end) {
      // For this demo, just create a direct path
      // In a real app, you'd implement Dijkstra's algorithm here
      pathToDestination = {
        start: start,
        end: end,
        path: [
          { x: start.imageX, y: start.imageY },
          { x: end.imageX, y: end.imageY }
        ]
      };
      
      // Redraw the map
      drawMap();
    }
    
    // Draw the map and all elements
    function drawMap() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Calculate scale to fit map to window
      const scale = Math.min(
        canvas.width / mapImage.width,
        canvas.height / mapImage.height
      ) * 0.9;
      
      // Calculate centered position
      const offsetX = (canvas.width - mapImage.width * scale) / 2;
      const offsetY = (canvas.height - mapImage.height * scale) / 2;
      
      // Save context
      ctx.save();
      
      // Draw map image
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);
      ctx.drawImage(mapImage, 0, 0);
      
      // Draw graph edges
      ctx.strokeStyle = 'rgba(0, 0, 255, 0.6)';
      ctx.lineWidth = 2 / scale;
      
      // Debug count of edges actually drawn
      let drawnEdges = 0;
      
      graphData.forEach(edge => {
        // Skip edges with NaN coordinates
        if (isNaN(edge.x1) || isNaN(edge.y1) || isNaN(edge.x2) || isNaN(edge.y2)) {
          return;
        }
        
        ctx.beginPath();
        ctx.moveTo(edge.x1, edge.y1);
        ctx.lineTo(edge.x2, edge.y2);
        ctx.stroke();
        drawnEdges++;
      });
      
      console.log(`Drew ${drawnEdges} edges out of ${graphData.length} total`);
      
      // Draw path to destination if available
      if (pathToDestination) {
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.lineWidth = 3 / scale;
        
        ctx.beginPath();
        ctx.moveTo(pathToDestination.path[0].x, pathToDestination.path[0].y);
        
        for (let i = 1; i < pathToDestination.path.length; i++) {
          ctx.lineTo(pathToDestination.path[i].x, pathToDestination.path[i].y);
        }
        
        ctx.stroke();
      }
      
      // Draw places
      places.forEach(place => {
        // Skip unnamed locations for cleaner visual
        if (place.name.startsWith('Location')) {
          return;
        }
        
        // Draw point
        ctx.beginPath();
        ctx.arc(place.imageX, place.imageY, 5 / scale, 0, Math.PI * 2);
        
        if (selectedPlace && selectedPlace.id === place.id) {
          ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        } else {
          ctx.fillStyle = 'rgba(0, 128, 255, 0.8)';
        }
        
        ctx.fill();
        
        // Draw label
        ctx.font = `${12 / scale}px Arial`;
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.fillText(place.name, place.imageX, place.imageY - 10 / scale);
      });
      
      // Draw user location if available
      if (userLocation) {
        // Draw outer glow
        const glowRadius = 12 / scale;
        const gradient = ctx.createRadialGradient(
          userLocation.imageX, userLocation.imageY, 0,
          userLocation.imageX, userLocation.imageY, glowRadius
        );
        gradient.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
        
        ctx.beginPath();
        ctx.arc(userLocation.imageX, userLocation.imageY, glowRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw position marker
        ctx.beginPath();
        ctx.arc(userLocation.imageX, userLocation.imageY, 8 / scale, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2 / scale;
        ctx.stroke();
        
        // Draw accuracy circle
        ctx.beginPath();
        ctx.arc(userLocation.imageX, userLocation.imageY, 15 / scale, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
        ctx.lineWidth = 1 / scale;
        ctx.stroke();
        
        // Draw "You are here" label
        ctx.font = `bold ${14 / scale}px Arial`;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.lineWidth = 3 / scale;
        ctx.strokeStyle = 'black';
        ctx.strokeText("YOU ARE HERE", userLocation.imageX, userLocation.imageY - 15 / scale);
        ctx.fillText("YOU ARE HERE", userLocation.imageX, userLocation.imageY - 15 / scale);
        
        // Show coordinates on map if in debug mode
        if (debugMode) {
          ctx.font = `${10 / scale}px monospace`;
          ctx.fillStyle = 'black';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(
            `(${userLocation.latitude.toFixed(4)}, ${userLocation.longitude.toFixed(4)})`, 
            userLocation.imageX, 
            userLocation.imageY + 20 / scale
          );
        }
      }
      
      // Draw location selection indicator when in selection mode
      if (isLocationSelectMode) {
        // Draw crosshair at mouse position
        const mouseX = lastMouseX || canvas.width / 2;
        const mouseY = lastMouseY || canvas.height / 2;
        
        // Convert to image coordinates
        const imgX = (mouseX - offsetX) / scale;
        const imgY = (mouseY - offsetY) / scale;
        
        // Only draw if within map bounds
        if (imgX >= 0 && imgX <= mapImage.width && imgY >= 0 && imgY <= mapImage.height) {
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
          ctx.lineWidth = 1 / scale;
          
          // Horizontal line
          ctx.beginPath();
          ctx.moveTo(imgX - 15 / scale, imgY);
          ctx.lineTo(imgX + 15 / scale, imgY);
          ctx.stroke();
          
          // Vertical line
          ctx.beginPath();
          ctx.moveTo(imgX, imgY - 15 / scale);
          ctx.lineTo(imgX, imgY + 15 / scale);
          ctx.stroke();
          
          // Draw circle
          ctx.beginPath();
          ctx.arc(imgX, imgY, 10 / scale, 0, Math.PI * 2);
          ctx.stroke();
          
          // Show potential coordinates
          const potentialGps = imageToGpsCoordinates(imgX, imgY);
          
          ctx.font = `${10 / scale}px monospace`;
          ctx.fillStyle = 'red';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(
            `(${potentialGps.latitude.toFixed(4)}, ${potentialGps.longitude.toFixed(4)})`, 
            imgX, 
            imgY + 20 / scale
          );
        }
      }
      
      // Restore context
      ctx.restore();
      
      // Update debug info if enabled
      if (debugMode) {
        updateDebugInfo();
      }
    }
    
    // Get user location
    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          position => {
            console.log('GPS location:', position.coords.latitude, position.coords.longitude);
            
            // Convert GPS to image coordinates
            const imgCoords = gpsToImageCoordinates(
              position.coords.longitude,
              position.coords.latitude
            );
            
            console.log('Converted to image coordinates:', imgCoords);
            
            // Check if coordinates are within reasonable bounds
            const isInBounds = imgCoords.x > -2000 && imgCoords.x < 3000 && 
                              imgCoords.y > -2000 && imgCoords.y < 1000;
            
            if (!isInBounds) {
              console.warn('GPS coordinates converted to out-of-bounds image coordinates');
              
              // Use a hardcoded position in the center of the school
              userLocation = {
                latitude: 37.36,
                longitude: -122.067,
                imageX: 1000, // Center X coordinate
                imageY: 500  // Center Y coordinate (positive now with inverted system)
              };
              
              locationInfo.textContent = `Your location: [Default]`;
              updateCoordinatesDisplay(userLocation.latitude, userLocation.longitude);
            } else {
              userLocation = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                imageX: imgCoords.x,
                imageY: imgCoords.y
              };
              
              locationInfo.textContent = `Your current location:`;
              updateCoordinatesDisplay(position.coords.latitude, position.coords.longitude);
            }
            
            // Redraw the map
            drawMap();
          },
          error => {
            console.error('Error getting location:', error);
            locationInfo.textContent = 'Error getting your location. Click map to set manually.';
            coordinatesDisplay.textContent = '';
            
            // Set a default location in the center of the school
            userLocation = {
              latitude: 37.36,
              longitude: -122.067,
              imageX: 1000, // Center X coordinate
              imageY: 500  // Center Y coordinate (positive now with inverted system)
            };
            
            // Redraw the map
            drawMap();
          }
        );
      } else {
        locationInfo.textContent = 'Geolocation is not supported by this browser.';
        coordinatesDisplay.textContent = '';
        
        // Set a default location
        userLocation = {
          latitude: 37.36,
          longitude: -122.067,
          imageX: 1000, // Center X coordinate
          imageY: 500  // Center Y coordinate (positive now with inverted system)
        };
        
        // Redraw the map
        drawMap();
      }
    }
    
    // Helper function to update coordinates display
    function updateCoordinatesDisplay(latitude, longitude) {
      const latDirection = latitude >= 0 ? 'N' : 'S';
      const lonDirection = longitude >= 0 ? 'E' : 'W';
      
      // Create formatted coordinates strings
      const latFormatted = `${Math.abs(latitude).toFixed(6)}° ${latDirection}`;
      const lonFormatted = `${Math.abs(longitude).toFixed(6)}° ${lonDirection}`;
      
      // Display the coordinates in the coordinates display element
      coordinatesDisplay.innerHTML = `
        <div>Latitude: ${latFormatted}</div>
        <div>Longitude: ${lonFormatted}</div>
      `;
      
      // Show the copy button
      copyButton.style.display = 'block';
    }
    
    // Copy coordinates to clipboard
    copyButton.addEventListener('click', () => {
      if (!userLocation) return;
      
      const latDirection = userLocation.latitude >= 0 ? 'N' : 'S';
      const lonDirection = userLocation.longitude >= 0 ? 'E' : 'W';
      
      // Format for clipboard
      const coordsText = `${Math.abs(userLocation.latitude).toFixed(6)}° ${latDirection}, ${Math.abs(userLocation.longitude).toFixed(6)}° ${lonDirection}`;
      
      // Use Clipboard API
      navigator.clipboard.writeText(coordsText).then(() => {
        // Show copied status
        copyStatus.style.display = 'block';
        
        // Hide after 2 seconds
        setTimeout(() => {
          copyStatus.style.display = 'none';
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy coordinates: ', err);
        alert('Could not copy coordinates to clipboard');
      });
    });
    
    // Convert GPS coordinates to image coordinates
    function gpsToImageCoordinates(longitude, latitude) {
      // Use the transformation from interpolation.py
      // Original formula: x = longitude * x_scale + x_offset; y = latitude * y_scale + y_offset
      
      console.log(`Converting GPS: long ${longitude}, lat ${latitude}`);
      console.log(`Using scales: x_scale ${x_scale}, y_scale ${y_scale}`);
      console.log(`Using offsets: x_offset ${x_offset}, y_offset ${y_offset}`);
      
      // Apply transformation
      const x = longitude * x_scale + x_offset;
      const y = -(latitude * y_scale + y_offset); // Invert y-coordinate
      
      // If resulting coordinates seem unreasonable, use a fallback
      // The image coordinates should be roughly in the range of the map dimensions
      if (Math.abs(x) > 10000 || Math.abs(y) > 10000) {
        console.warn(`Transformed coordinates (${x}, ${y}) seem out of reasonable range`);
        
        // Try alternative transformation (simpler linear mapping)
        // Map from typical GPS range to image coordinates
        // For Cupertino area - roughly (37.32, -122.03) to (37.36, -122.07)
        
        // Simple linear mapping as fallback
        const mapWidth = 2000;  // Approximate width of the map in pixels
        const mapHeight = 1000; // Approximate height of the map in pixels
        
        // GPS bounds for the area (approximate)
        const lonMin = -122.07;
        const lonMax = -122.03;
        const latMin = 37.32;
        const latMax = 37.36;
        
        // Convert using linear interpolation with inverted y-axis
        const x2 = mapWidth * (longitude - lonMin) / (lonMax - lonMin);
        // For inverted y-axis, we now use (latitude - latMin) directly, not (1 - ...)
        const y2 = mapHeight * ((latitude - latMin) / (latMax - latMin));
        
        console.log(`Using fallback transformation: (${x2}, ${y2})`);
        return { x: x2, y: y2 };
      }
      
      console.log(`Transformed coordinates: (${x}, ${y})`);
      return { x, y };
    }
    
    // Convert image coordinates to GPS coordinates
    function imageToGpsCoordinates(x, y) {
      // Check if we should use the fallback transformation
      if (Math.abs(x) > 10000 || Math.abs(y) > 10000) {
        // Use inverse of the fallback transformation
        const mapWidth = 2000;
        const mapHeight = 1000;
        
        // GPS bounds for the area (approximate)
        const lonMin = -122.07;
        const lonMax = -122.03;
        const latMin = 37.32;
        const latMax = 37.36;
        
        // Convert using linear interpolation with inverted y-axis
        const longitude = lonMin + (x / mapWidth) * (lonMax - lonMin);
        // For inverted y-axis
        const latitude = latMin + (y / mapHeight) * (latMax - latMin);
        
        return { longitude, latitude };
      }
      
      // Inverse of the transformation from interpolation.py with inverted y
      const longitude = (x - x_offset) / x_scale;
      const latitude = -(y - y_offset) / y_scale; // Invert y-coordinate calculation
      return { longitude, latitude };
    }
    
    // Update debug info
    function updateDebugInfo() {
      if (!debugMode) return;
      
      let html = '<h3>Debug Info</h3>';
      
      if (userLocation) {
        html += '<p><strong>User Location:</strong><br>';
        html += `GPS: ${userLocation.latitude.toFixed(8)}° ${userLocation.latitude >= 0 ? 'N' : 'S'}, `;
        html += `${Math.abs(userLocation.longitude).toFixed(8)}° ${userLocation.longitude >= 0 ? 'E' : 'W'}<br>`;
        html += `Image: (${userLocation.imageX.toFixed(1)}, ${userLocation.imageY.toFixed(1)})</p>`;
      }
      
      if (selectedPlace) {
        html += `<p><strong>Selected Place:</strong> ${selectedPlace.name}<br>`;
        html += `GPS: ${selectedPlace.latitude.toFixed(8)}° ${selectedPlace.latitude >= 0 ? 'N' : 'S'}, `;
        html += `${Math.abs(selectedPlace.longitude).toFixed(8)}° ${selectedPlace.longitude >= 0 ? 'E' : 'W'}<br>`;
        html += `Image: (${selectedPlace.imageX.toFixed(1)}, ${selectedPlace.imageY.toFixed(1)})</p>`;
      }
      
      html += `<p><strong>Map Data:</strong><br>`;
      html += `Graph: ${graphData.length} edges<br>`;
      html += `Places: ${places.length} locations</p>`;
      
      debugInfo.innerHTML = html;
    }
    
    // Handle search button click
    searchButton.addEventListener('click', () => {
      const searchTerm = searchInput.value.trim().toLowerCase();
      if (!searchTerm) return;
      
      // Find matching places
      const matches = places.filter(place => 
        place.name.toLowerCase().includes(searchTerm)
      );
      
      if (matches.length > 0) {
        // Select the first match
        selectPlace(matches[0]);
        searchInput.value = '';
      } else {
        alert('No matching places found');
      }
    });
    
    // Allow Enter key to trigger search
    searchInput.addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        searchButton.click();
      }
    });
    
    // Handle location select mode keyboard shortcut (Ctrl+Shift+L)
    document.addEventListener('keydown', event => {
      if (event.key.toLowerCase() === 'l' && event.ctrlKey && event.shiftKey) {
        event.preventDefault();
        
        isLocationSelectMode = !isLocationSelectMode;
        locationSelectMode.style.display = isLocationSelectMode ? 'block' : 'none';
        
        if (isLocationSelectMode) {
          canvas.style.cursor = 'crosshair';
          locationInfo.textContent = 'Click on the map to set your location';
        } else {
          canvas.style.cursor = 'default';
          if (userLocation) {
            locationInfo.textContent = 'Your location:';
            updateCoordinatesDisplay(userLocation.latitude, userLocation.longitude);
          } else {
            locationInfo.textContent = 'Your location: Not set';
          }
        }
      } else if (event.key.toLowerCase() === 'd') {
        // Toggle debug mode
        debugMode = !debugMode;
        debugInfo.style.display = debugMode ? 'block' : 'none';
        
        if (debugMode) {
          updateDebugInfo();
        }
      }
    });
    
    // Set up manual location button
    manualLocationButton.addEventListener('click', () => {
      // Enter location select mode
      isLocationSelectMode = true;
      locationSelectMode.style.display = 'block';
      canvas.style.cursor = 'crosshair';
      locationInfo.textContent = 'Click anywhere on the map to set your location';
    });
    
    // Get clicked location - Alternative keybind (L key alone)
    document.addEventListener('keydown', event => {
      if (event.key.toLowerCase() === 'l' && !event.ctrlKey && !event.shiftKey) {
        // Toggle location select mode
        isLocationSelectMode = !isLocationSelectMode;
        locationSelectMode.style.display = isLocationSelectMode ? 'block' : 'none';
        
        if (isLocationSelectMode) {
          canvas.style.cursor = 'crosshair';
          locationInfo.textContent = 'LOCATION SELECT MODE: Click anywhere on the map';
        } else {
          canvas.style.cursor = 'default';
          if (userLocation) {
            locationInfo.textContent = 'Your location:';
            updateCoordinatesDisplay(userLocation.latitude, userLocation.longitude);
          } else {
            locationInfo.textContent = 'Your location: Not set';
          }
        }
      }
    });
    
    // Handle map clicks for location selection
    canvas.addEventListener('click', event => {
      if (!isLocationSelectMode) return;
      
      // Calculate scale to fit map to window
      const scale = Math.min(
        canvas.width / mapImage.width,
        canvas.height / mapImage.height
      ) * 0.9;
      
      // Calculate centered position
      const offsetX = (canvas.width - mapImage.width * scale) / 2;
      const offsetY = (canvas.height - mapImage.height * scale) / 2;
      
      // Convert click position to image coordinates
      const imageX = (event.clientX - offsetX) / scale;
      const imageY = (event.clientY - offsetY) / scale;
      
      // Only accept clicks within the image bounds
      if (imageX >= 0 && imageX <= mapImage.width && imageY >= 0 && imageY <= mapImage.height) {
        // Convert to GPS coordinates
        const gps = imageToGpsCoordinates(imageX, imageY);
        
        console.log('Manual location set:', gps);
        
        // Update user location
        userLocation = {
          latitude: gps.latitude,
          longitude: gps.longitude,
          imageX: imageX,
          imageY: imageY
        };
        
        // Update UI
        locationInfo.textContent = 'Your selected location:';
        updateCoordinatesDisplay(gps.latitude, gps.longitude);
        
        // If a place is selected, find path
        if (selectedPlace) {
          findPath(userLocation, selectedPlace);
        }
        
        // Exit location select mode
        isLocationSelectMode = false;
        locationSelectMode.style.display = 'none';
        canvas.style.cursor = 'default';
        
        // Update debug info if enabled
        if (debugMode) {
          updateDebugInfo();
        }
        
        // Redraw the map
        drawMap();
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      resizeCanvas();
      drawMap();
    });
    
    // Track mouse position for crosshair
    canvas.addEventListener('mousemove', event => {
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      
      // Redraw the map if in location select mode
      if (isLocationSelectMode) {
        drawMap();
      }
    });
    
    // Start the application
    init();
    
    // Debug message to verify the script ran completely
    console.log('Map application initialized');
  </script>
</body>
</html> 